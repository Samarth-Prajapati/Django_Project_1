{% extends 'base.html' %} {% load static %} {% block title %}Canvas Resource
Tree{% endblock %} {% block content %}
<style>
  .canvas-container {
    position: relative;
    width: 100%;
    height: 80vh;
    overflow: hidden;
    cursor: grab;
    background: radial-gradient(circle at center, #f8f9fa 0%, #e9ecef 100%);
    box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    margin-top: 20px;
  }

  .canvas-container.dragging {
    cursor: grabbing;
  }

  #treeCanvas {
    display: block;
    border-radius: 8px;
  }

  .controls-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    width: 250px;
    max-height: calc(100vh - 200px);
    overflow-y: auto;
    z-index: 1000;
  }

  .controls-panel h5 {
    color: #2c3e50;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.95em;
  }

  .legend {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    position: absolute;
    top: 10px;
    right: 10px;
    width: 280px;
    z-index: 1000;
  }

  .legend h5 {
    color: #2c3e50;
    margin-bottom: 12px;
    font-weight: 600;
    font-size: 0.95em;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    padding: 6px 8px;
    border-radius: 6px;
    transition: background-color 0.2s;
    font-size: 0.85em;
  }

  .legend-item:hover {
    background-color: rgba(52, 152, 219, 0.1);
  }

  .legend-icon {
    width: 16px;
    height: 16px;
    margin-right: 10px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    color: white;
    flex-shrink: 0;
  }

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(248, 249, 250, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    border-radius: 8px;
  }

  .loading-content {
    text-align: center;
    color: #495057;
  }

  .loading-content i {
    font-size: 3rem;
    color: #007bff;
    animation: spin 2s linear infinite;
    margin-bottom: 1rem;
  }

  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }

  .btn-icon {
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2px;
    transition: all 0.2s;
    font-size: 14px;
    cursor: pointer;
  }

  .btn-icon:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  .btn-zoom {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
  }

  .btn-zoom:hover {
    background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
  }

  .btn-center {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
  }

  .btn-center:hover {
    background: linear-gradient(135deg, #ee82e9 0%, #f3455a 100%);
  }

  .btn-expand {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
  }

  .btn-expand:hover {
    background: linear-gradient(135deg, #3d9bec 0%, #00e0ec 100%);
  }

  .btn-collapse {
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
    color: #2c3e50;
  }

  .btn-collapse:hover {
    background: linear-gradient(135deg, #96dbd6 0%, #fcc4d1 100%);
  }

  .resource-selector {
    margin-bottom: 15px;
  }

  .resource-selector select {
    border: 1px solid #e9ecef;
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 0.9em;
    transition: border-color 0.2s, box-shadow 0.2s;
    width: 100%;
  }

  .resource-selector select:focus {
    outline: none;
    border-color: #007bff;
    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
  }

  .btn-group-vertical {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
</style>

<div class="container-fluid">
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-center mb-4">
        <div>
          <h2 class="mb-1">
            <i class="fas fa-users text-primary me-3"></i>
            Resource Tree Visualization
          </h2>
          <p class="text-muted mb-0">
            Interactive canvas-based resource tree showing projects and
            relationships
          </p>
        </div>
        <div>
          <a
            href="{% url 'resources:resource_list' %}"
            class="btn btn-outline-primary me-2"
          >
            <i class="fas fa-list me-2"></i>Resource List
          </a>
          <a href="{% url 'home' %}" class="btn btn-primary">
            <i class="fas fa-home me-2"></i>Dashboard
          </a>
        </div>
      </div>

      <div class="canvas-container" id="canvasContainer">
        <canvas id="treeCanvas"></canvas>

        <!-- Controls Panel -->
        <div class="controls-panel">
          <h5>
            <i class="fas fa-cogs text-primary"></i>
            Controls
          </h5>

          <!-- Resource Selector -->
          <div class="resource-selector">
            <label class="form-label">
              <i class="fas fa-user me-1"></i>
              Select Resource
            </label>
            <select id="resourceSelector" class="form-select">
              <option value="">All Resources</option>
            </select>
          </div>

          <div class="btn-group-vertical" role="group">
            <button
              class="btn-icon btn-zoom"
              onclick="tree.zoomIn()"
              title="Zoom In"
            >
              <i class="fas fa-search-plus"></i>
            </button>
            <button
              class="btn-icon btn-zoom"
              onclick="tree.zoomOut()"
              title="Zoom Out"
            >
              <i class="fas fa-search-minus"></i>
            </button>
            <button
              class="btn-icon btn-center"
              onclick="tree.centerView()"
              title="Center View"
            >
              <i class="fas fa-crosshairs"></i>
            </button>
            <button
              class="btn-icon btn-expand"
              onclick="tree.expandAll()"
              title="Expand All"
            >
              <i class="fas fa-expand-alt"></i>
            </button>
            <button
              class="btn-icon btn-collapse"
              onclick="tree.collapseAll()"
              title="Collapse All"
            >
              <i class="fas fa-compress-alt"></i>
            </button>
          </div>
        </div>

        <!-- Legend -->
        <div class="legend">
          <h5>
            <i class="fas fa-info-circle text-info"></i>
            Legend
          </h5>
          <div class="legend-item">
            <div
              class="legend-icon"
              style="
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              "
            >
              <i class="fas fa-user"></i>
            </div>
            <span>Resource</span>
          </div>
          <div class="legend-item">
            <div
              class="legend-icon"
              style="
                background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
              "
            >
              <i class="fas fa-tasks"></i>
            </div>
            <span>Assigned Projects</span>
          </div>
          <div class="legend-item">
            <div
              class="legend-icon"
              style="
                background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
              "
            >
              <i class="fas fa-bullseye"></i>
            </div>
            <span>POC Projects</span>
          </div>
          <div class="legend-item">
            <div
              class="legend-icon"
              style="
                background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
              "
            >
              <i class="fas fa-user-tie"></i>
            </div>
            <span>Directly Assigned</span>
          </div>
          <div class="legend-item">
            <div
              class="legend-icon"
              style="
                background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
              "
            >
              <i class="fas fa-project-diagram"></i>
            </div>
            <span>Project</span>
          </div>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay">
          <div class="loading-content">
            <i class="fas fa-spinner"></i>
            <h5>Loading Resource Tree...</h5>
            <p>Please wait while we fetch your resource data</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  class InteractiveResourceTree {
    constructor(canvasId, apiUrl) {
      this.canvas = document.getElementById(canvasId);
      this.ctx = this.canvas.getContext("2d");
      this.apiUrl = apiUrl;
      this.nodes = [];
      this.allNodes = [];
      this.nodeRadius = 25;
      this.selectedResource = "";

      // Pan and zoom
      this.panX = 0;
      this.panY = 0;
      this.scale = 1;
      this.minScale = 0.1;
      this.maxScale = 3;

      // Dragging
      this.isDragging = false;
      this.lastMouseX = 0;
      this.lastMouseY = 0;

      // Colors
      this.colors = {
        resource: { start: "#667eea", end: "#764ba2" },
        assignedProjects: { start: "#4facfe", end: "#00f2fe" },
        pocProjects: { start: "#f093fb", end: "#f5576c" },
        directlyAssigned: { start: "#a8edea", end: "#fed6e3" },
        project: { start: "#43e97b", end: "#38f9d7" },
        connection: "#e9ecef",
      };

      this.setupCanvas();
      this.setupEventListeners();
      this.loadData();
      this.loadResourceSelector();
    }

    setupCanvas() {
      const container = this.canvas.parentElement;
      this.canvas.width = container.clientWidth;
      this.canvas.height = container.clientHeight;

      window.addEventListener("resize", () => {
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.draw();
      });
    }

    setupEventListeners() {
      // Mouse events for panning
      this.canvas.addEventListener("mousedown", (e) => {
        this.isDragging = true;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        this.canvas.parentElement.classList.add("dragging");
      });

      this.canvas.addEventListener("mousemove", (e) => {
        if (this.isDragging) {
          const deltaX = e.clientX - this.lastMouseX;
          const deltaY = e.clientY - this.lastMouseY;
          this.panX += deltaX;
          this.panY += deltaY;
          this.lastMouseX = e.clientX;
          this.lastMouseY = e.clientY;
          this.draw();
        }
      });

      this.canvas.addEventListener("mouseup", () => {
        this.isDragging = false;
        this.canvas.parentElement.classList.remove("dragging");
      });

      this.canvas.addEventListener("mouseleave", () => {
        this.isDragging = false;
        this.canvas.parentElement.classList.remove("dragging");
      });

      // Wheel event for zooming
      this.canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const wheel = e.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * 0.1);
        const newScale = Math.max(
          this.minScale,
          Math.min(this.maxScale, this.scale * zoom)
        );

        if (newScale !== this.scale) {
          // Zoom towards mouse position
          const worldX = (mouseX - this.panX) / this.scale;
          const worldY = (mouseY - this.panY) / this.scale;

          this.scale = newScale;

          this.panX = mouseX - worldX * this.scale;
          this.panY = mouseY - worldY * this.scale;

          this.draw();
        }
      });

      // Resource selector
      document
        .getElementById("resourceSelector")
        .addEventListener("change", (e) => {
          this.selectedResource = e.target.value;
          this.filterNodes();
          this.layoutNodes();
          this.draw();
        });
    }

    async loadData() {
      try {
        const response = await fetch(this.apiUrl);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        this.allNodes = this.processNodes(data);
        this.nodes = [...this.allNodes];
        this.layoutNodes();
        this.centerView();
        this.draw();
        this.hideLoading();
      } catch (error) {
        console.error("Error loading data:", error);
        this.showError(
          "Failed to load resource tree data. Please try again later."
        );
      }
    }

    async loadResourceSelector() {
      try {
        const response = await fetch('{% url "resources:resource_list_api" %}');
        const resources = await response.json();
        const selector = document.getElementById("resourceSelector");

        resources.forEach((resource) => {
          const option = document.createElement("option");
          option.value = resource.name;
          option.textContent = `${resource.name} (${resource.present_day} days)`;
          selector.appendChild(option);
        });
      } catch (error) {
        console.error("Error loading resource selector:", error);
      }
    }

    processNodes(data, parentX = 0, parentY = 0, level = 0) {
      const nodes = [];
      const horizontalSpacing = 300;
      const verticalSpacing = 100;
      let yOffset = 0;

      data.forEach((item, index) => {
        const x = level * horizontalSpacing;
        const y = parentY + index * verticalSpacing * 3; // More spacing for resources

        const node = {
          id: `${level}-${index}`,
          text: item.text,
          icon: item.icon,
          x: x,
          y: y,
          level: level,
          expanded: item.opened !== false,
          visible: true,
          children: [],
          parent: null,
          type: this.getNodeType(item.text, level),
          opacity: 1,
        };

        nodes.push(node);

        if (item.children && item.children.length > 0) {
          const childNodes = this.processNodes(item.children, x, y, level + 1);

          childNodes.forEach((child) => {
            child.parent = node;
            node.children.push(child);
          });

          nodes.push(...childNodes);
        }

        yOffset += verticalSpacing;
      });

      return nodes;
    }

    getNodeType(text, level) {
      if (level === 0) return "resource";
      if (text.includes("Assigned Projects")) return "assignedProjects";
      if (text.includes("POC Projects")) return "pocProjects";
      if (text.includes("Directly Assigned")) return "directlyAssigned";
      return "project";
    }

    filterNodes() {
      if (!this.selectedResource) {
        this.nodes = [...this.allNodes];
        this.nodes.forEach((node) => {
          node.visible = true;
          node.opacity = 1;
        });
      } else {
        // Show only the selected resource and its children
        this.nodes = this.allNodes.filter((node) => {
          // Find the root resource for this node
          let rootNode = node;
          while (rootNode.parent) {
            rootNode = rootNode.parent;
          }

          if (rootNode.text === this.selectedResource) {
            node.visible = true;
            node.opacity = 1;
            return true;
          } else {
            node.visible = false;
            node.opacity = 0.3;
            return false;
          }
        });
      }
    }

    layoutNodes() {
      if (this.nodes.length === 0) return;

      const horizontalSpacing = 320;
      const verticalSpacing = 80;
      const resourceSpacing = 250; // Extra spacing between different resources

      let currentY = 50;
      let resourceIndex = 0;

      // Group nodes by resource (level 0 nodes)
      const resources = this.nodes.filter(
        (node) => node.level === 0 && node.visible
      );

      resources.forEach((resourceNode) => {
        // Position the resource node
        resourceNode.x = 50;
        resourceNode.y = currentY;

        // Layout children of this resource
        this.layoutResourceChildren(
          resourceNode,
          resourceNode.x + horizontalSpacing,
          resourceNode.y
        );

        // Move to next resource position
        const resourceHeight = this.calculateResourceHeight(resourceNode);
        currentY += Math.max(resourceHeight, 150) + resourceSpacing;
      });
    }

    layoutResourceChildren(parentNode, startX, startY) {
      const children = parentNode.children.filter((child) => child.visible);
      const verticalSpacing = 60;

      let currentY = startY - ((children.length - 1) * verticalSpacing) / 2;

      children.forEach((child, index) => {
        child.x = startX;
        child.y = currentY + index * verticalSpacing;

        if (child.children && child.children.length > 0 && child.expanded) {
          this.layoutResourceChildren(child, child.x + 320, child.y);
        }
      });
    }

    calculateResourceHeight(resourceNode) {
      let height = 0;
      const countVisibleDescendants = (node) => {
        let count = 1;
        if (node.children && node.expanded) {
          node.children.forEach((child) => {
            if (child.visible) {
              count += countVisibleDescendants(child);
            }
          });
        }
        return count;
      };

      return countVisibleDescendants(resourceNode) * 60;
    }

    draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.save();
      this.ctx.translate(this.panX, this.panY);
      this.ctx.scale(this.scale, this.scale);

      // Draw connections first
      this.drawConnections();

      // Draw nodes
      this.nodes
        .filter((node) => node.visible)
        .forEach((node) => this.drawNode(node));

      this.ctx.restore();
    }

    drawConnections() {
      this.ctx.strokeStyle = this.colors.connection;
      this.ctx.lineWidth = 2;
      this.ctx.globalAlpha = 0.6;

      this.nodes
        .filter(
          (node) =>
            node.visible &&
            node.parent &&
            node.parent.visible &&
            node.parent.expanded
        )
        .forEach((node) => {
          this.ctx.beginPath();
          this.ctx.moveTo(node.parent.x + this.nodeRadius, node.parent.y);
          this.ctx.lineTo(node.x - this.nodeRadius, node.y);
          this.ctx.stroke();
        });

      this.ctx.globalAlpha = 1;
    }

    drawNode(node) {
      this.ctx.save();
      this.ctx.globalAlpha = node.opacity;

      // Create gradient based on node type
      const gradient = this.ctx.createLinearGradient(
        node.x - this.nodeRadius,
        node.y - this.nodeRadius,
        node.x + this.nodeRadius,
        node.y + this.nodeRadius
      );

      const colors = this.colors[node.type] || this.colors.project;
      gradient.addColorStop(0, colors.start);
      gradient.addColorStop(1, colors.end);

      // Draw node circle
      this.ctx.beginPath();
      this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);
      this.ctx.fillStyle = gradient;
      this.ctx.fill();

      // Draw border
      this.ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      this.ctx.lineWidth = 3;
      this.ctx.stroke();

      // Draw text
      this.ctx.fillStyle = "#2c3e50";
      this.ctx.font = `${Math.max(10, 12 / this.scale)}px Arial`;
      this.ctx.textAlign = "left";

      const maxTextWidth = 200;
      const words = node.text.split(" ");
      let line = "";
      let lines = [];

      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + " ";
        const metrics = this.ctx.measureText(testLine);
        const testWidth = metrics.width;

        if (testWidth > maxTextWidth && n > 0) {
          lines.push(line.trim());
          line = words[n] + " ";
        } else {
          line = testLine;
        }
      }
      lines.push(line.trim());

      // Draw text lines
      const lineHeight = Math.max(12, 14 / this.scale);
      const startY = node.y - ((lines.length - 1) * lineHeight) / 2;

      lines.forEach((line, index) => {
        this.ctx.fillText(
          line,
          node.x + this.nodeRadius + 10,
          startY + index * lineHeight
        );
      });

      this.ctx.restore();
    }

    zoomIn() {
      this.setZoom(this.scale * 1.2);
    }

    zoomOut() {
      this.setZoom(this.scale / 1.2);
    }

    setZoom(newScale) {
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;

      const worldX = (centerX - this.panX) / this.scale;
      const worldY = (centerY - this.panY) / this.scale;

      this.scale = Math.max(this.minScale, Math.min(this.maxScale, newScale));

      this.panX = centerX - worldX * this.scale;
      this.panY = centerY - worldY * this.scale;

      this.draw();
    }

    centerView() {
      if (this.nodes.length === 0) return;

      const visibleNodes = this.nodes.filter((node) => node.visible);
      if (visibleNodes.length === 0) return;

      const bounds = this.getNodeBounds(visibleNodes);
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const centerY = (bounds.minY + bounds.maxY) / 2;

      this.panX = this.canvas.width / 2 - centerX * this.scale;
      this.panY = this.canvas.height / 2 - centerY * this.scale;

      this.draw();
    }

    getNodeBounds(nodes) {
      if (nodes.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };

      let minX = nodes[0].x;
      let maxX = nodes[0].x;
      let minY = nodes[0].y;
      let maxY = nodes[0].y;

      nodes.forEach((node) => {
        minX = Math.min(minX, node.x - this.nodeRadius);
        maxX = Math.max(maxX, node.x + this.nodeRadius + 200); // Account for text
        minY = Math.min(minY, node.y - this.nodeRadius);
        maxY = Math.max(maxY, node.y + this.nodeRadius);
      });

      return { minX, maxX, minY, maxY };
    }

    expandAll() {
      this.nodes.forEach((node) => {
        if (node.children && node.children.length > 0) {
          node.expanded = true;
          node.children.forEach((child) => {
            if (child.visible) {
              child.visible = true;
            }
          });
        }
      });

      this.layoutNodes();
      this.draw();
    }

    collapseAll() {
      this.nodes.forEach((node) => {
        if (node.level > 0) {
          if (node.level > 1) {
            node.visible = false;
            node.expanded = false;
          } else {
            node.expanded = false;
          }
          node.opacity = 1;
        }
      });

      this.layoutNodes();
      this.centerView();
      this.setZoom(1);
    }

    hideLoading() {
      document.getElementById("loadingOverlay").style.display = "none";
    }

    showError(message) {
      document.getElementById("loadingOverlay").innerHTML = `
        <div style="text-align: center; color: #e74c3c;">
          <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i>
          <h4>Error</h4>
          <p>${message}</p>
        </div>
      `;
    }
  }

  // Initialize the tree when the page loads
  document.addEventListener("DOMContentLoaded", function () {
    const tree = new InteractiveResourceTree(
      "treeCanvas",
      '{% url "resources:resource_tree" %}'
    );

    // Make tree available globally for button controls
    window.tree = tree;
  });
</script>
{% endblock %}
