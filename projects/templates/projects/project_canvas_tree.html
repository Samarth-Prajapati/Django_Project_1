{% extends 'base.html' %}
{% load static %}

{% block title %}Canvas Project Tree{% endblock %}

{% block content %}
<style>
  .canvas-container {
    position: relative;
    width: 100%;
    height: 80vh;
    overflow: hidden;
    cursor: grab;
    background: radial-gradient(circle at center, #f8f9fa 0%, #e9ecef 100%);
    box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    margin-top: 20px;
  }

  .canvas-container.dragging {
    cursor: grabbing;
  }

  #treeCanvas {
    display: block;
    border-radius: 8px;
  }

  .controls-panel {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        width: 250px;
        max-height: calc(100vh - 200px);
        overflow-y: auto;
        z-index: 1000;
      }

      .controls-panel h5 {
        color: #2c3e50;
        margin-bottom: 8px;
        font-weight: 600;
        font-size: 0.95em;
      }

      .control-group {
        margin-bottom: 8px;
      }

      .control-group label {
        display: block;
        margin-bottom: 3px;
        font-size: 0.75em;
        color: #555;
        font-weight: 500;
      }

      .btn-control {
        padding: 4px 8px;
        margin: 1px;
        border-radius: 5px;
        border: none;
        font-size: 0.7em;
        font-weight: 500;
        transition: all 0.3s ease;
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
      }

      .btn-control:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .zoom-controls {
        display: flex;
        gap: 5px;
        align-items: center;
      }

      .zoom-level {
        font-size: 0.75em;
        color: #666;
        min-width: 35px;
        text-align: center;
      }

      .legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        width: 220px;
        z-index: 1000;
      }

      .legend h6 {
        color: #2c3e50;
        margin-bottom: 6px;
        font-weight: 600;
        font-size: 0.85em;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 3px;
        font-size: 0.7em;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 2px;
        margin-right: 5px;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .info-panel {
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 15px;
        padding: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 280px;
        display: none;
        z-index: 1001;
      }

      .info-panel h6 {
        color: #2c3e50;
        margin-bottom: 10px;
        font-weight: 600;
        font-size: 0.95em;
      }

      .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        z-index: 1000;
      }

      .spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .search-box {
        position: relative;
      }

      .search-box input {
        width: 100%;
        padding: 6px 28px 6px 8px;
        border: 2px solid #e9ecef;
        border-radius: 6px;
        font-size: 0.75em;
        transition: border-color 0.3s ease;
      }

      .search-box input:focus {
        outline: none;
        border-color: #667eea;
      }

      .search-box i {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        color: #666;
        font-size: 0.8em;
      }

      .home-button {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        padding: 10px 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        text-decoration: none;
        color: #2c3e50;
        font-weight: 500;
        font-size: 0.9em;
        transition: all 0.3s ease;
        z-index: 1002;
      }

      .home-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        color: #667eea;
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .controls-panel {
          position: absolute;
          top: 10px;
          left: 10px;
          right: 10px;
          width: auto;
          max-width: none;
          max-height: 40vh;
          z-index: 1000;
        }

        .legend {
          position: absolute;
          bottom: 10px;
          left: 10px;
          right: 10px;
          width: auto;
          max-width: none;
          z-index: 1000;
        }

        .info-panel {
          position: absolute;
          top: 50vh;
          right: 10px;
          left: 10px;
          max-width: none;
          transform: translateY(-50%);
          z-index: 1001;
        }

        .canvas-container {
          height: 100vh;
        }

        .home-button {
          position: absolute;
          top: 10px;
          right: 10px;
          z-index: 1002;
          padding: 8px 15px;
          font-size: 0.85em;
        }

        .control-group {
          margin-bottom: 8px;
        }

        .btn-control {
          padding: 5px 10px;
          font-size: 0.75em;
        }

        .legend-item {
          font-size: 0.75em;
        }
      }

      @media (max-width: 480px) {
        .controls-panel,
        .legend {
          border-radius: 10px;
          padding: 10px;
        }

        .home-button {
          padding: 6px 12px;
          font-size: 0.8em;
        }
      }
    </style>

<div class="container-fluid mt-3">

  
  <div class="row">
    <div class="col-12">
      <div class="canvas-container" id="canvasContainer">
        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay">
          <div class="spinner"></div>
          <p style="margin-top: 20px; color: #666">Loading project tree...</p>
        </div>

        <!-- Main Canvas -->
        <canvas id="treeCanvas"></canvas>

        <!-- Home Button -->
        <a href="{% url 'projects:dashboard_home' %}" class="home-button">
          <i class="fas fa-home"></i> Back to Dashboard
        </a>

      <!-- Controls Panel -->
      <div class="controls-panel">
        <h5><i class="fas fa-cogs"></i> Tree Controls</h5>

        <!-- Search -->
        <div class="control-group">
          <label>Search Projects</label>
          <div class="search-box">
            <input
              type="text"
              id="searchInput"
              placeholder="Type to search..."
            />
            <i class="fas fa-search"></i>
          </div>
        </div>

        <!-- Zoom Controls -->
        <div class="control-group">
          <label>Zoom Level</label>
          <div class="zoom-controls">
            <button class="btn-control" id="zoomOut">
              <i class="fas fa-minus"></i>
            </button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="btn-control" id="zoomIn">
              <i class="fas fa-plus"></i>
            </button>
          </div>
        </div>

        <!-- View Controls -->
        <div class="control-group">
          <label>View Options</label>
          <div>
            <button class="btn-control" id="centerView">
              <i class="fas fa-crosshairs"></i> Center
            </button>
            <button class="btn-control" id="fitView">
              <i class="fas fa-expand-arrows-alt"></i> Fit All
            </button>
          </div>
        </div>

        <!-- Layout Controls -->
        <div class="control-group">
          <label>Layout</label>
          <div>
            <button class="btn-control" id="layoutVertical">
              <i class="fas fa-arrows-alt-v"></i> Vertical
            </button>
            <button class="btn-control" id="layoutHorizontal">
              <i class="fas fa-arrows-alt-h"></i> Horizontal
            </button>
          </div>
        </div>

        <!-- Animation Controls -->
        <div class="control-group">
          <label>Animation</label>
          <div>
            <button class="btn-control" id="toggleAnimation">
              <i class="fas fa-play"></i> Toggle
            </button>
            <button class="btn-control" id="resetView">
              <i class="fas fa-undo"></i> Reset
            </button>
          </div>
        </div>
      </div>

      <!-- Info Panel -->
      <div class="info-panel" id="infoPanel">
        <h6><i class="fas fa-info-circle"></i> Node Information</h6>
        <div id="nodeInfo"></div>
      </div>

      <!-- Legend -->
      <div class="legend">
        <h6><i class="fas fa-palette"></i> Legend</h6>
        <div class="legend-item">
          <div class="legend-color" style="background: #3498db"></div>
          <span>Main Root (All Projects)</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #2ecc71"></div>
          <span>Individual Projects</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #f39c12"></div>
          <span>Assigned Resources</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #9b59b6"></div>
          <span>Resource Groups</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #1abc9c"></div>
          <span>Individual Resources</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #e74c3c"></div>
          <span>POC (Point of Contact)</span>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      class InteractiveProjectTree {
        constructor(canvasId, dataUrl) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.dataUrl = dataUrl;

          // Tree data and layout
          this.nodes = [];
          this.rawData = [];
          this.selectedNode = null;
          this.hoveredNode = null;

          // View state
          this.zoom = 1;
          this.panX = 0;
          this.panY = 0;
          this.isDragging = false;
          this.lastMousePos = { x: 0, y: 0 };
          this.isVerticalLayout = true;
          this.animationEnabled = true;

          // Node styling
          this.nodeColors = {
            root: "#3498db",
            project: "#2ecc71",
            assigned: "#f39c12",
            resources: "#9b59b6",
            resource: "#1abc9c",
            poc: "#e74c3c",
            default: "#95a5a6",
          };

          // Animation properties
          this.animationFrame = null;
          this.targetPositions = new Map();

          this.init();
        }

        async init() {
          this.setupCanvas();
          this.setupEventListeners();
          await this.loadData();
          this.hideLoading();
          this.layoutNodes();
          this.centerView();
          this.render();
        }

        setupCanvas() {
          const container = document.getElementById("canvasContainer");
          this.canvas.width = container.clientWidth;
          this.canvas.height = container.clientHeight;

          // High DPI support
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width *= dpr;
          this.canvas.height *= dpr;
          this.canvas.style.width = container.clientWidth + "px";
          this.canvas.style.height = container.clientHeight + "px";
          this.ctx.scale(dpr, dpr);
        }

        setupEventListeners() {
          // Mouse events
          this.canvas.addEventListener(
            "mousedown",
            this.onMouseDown.bind(this)
          );
          this.canvas.addEventListener(
            "mousemove",
            this.onMouseMove.bind(this)
          );
          this.canvas.addEventListener("mouseup", this.onMouseUp.bind(this));
          this.canvas.addEventListener("wheel", this.onWheel.bind(this));
          this.canvas.addEventListener("click", this.onClick.bind(this));

          // Touch events for mobile
          this.canvas.addEventListener(
            "touchstart",
            this.onTouchStart.bind(this)
          );
          this.canvas.addEventListener(
            "touchmove",
            this.onTouchMove.bind(this)
          );
          this.canvas.addEventListener("touchend", this.onTouchEnd.bind(this));

          // Control buttons
          document
            .getElementById("zoomIn")
            .addEventListener("click", () => this.zoomIn());
          document
            .getElementById("zoomOut")
            .addEventListener("click", () => this.zoomOut());
          document
            .getElementById("centerView")
            .addEventListener("click", () => this.centerView());
          document
            .getElementById("fitView")
            .addEventListener("click", () => this.fitToView());
          document
            .getElementById("layoutVertical")
            .addEventListener("click", () => this.setLayout(true));
          document
            .getElementById("layoutHorizontal")
            .addEventListener("click", () => this.setLayout(false));
          document
            .getElementById("toggleAnimation")
            .addEventListener("click", () => this.toggleAnimation());
          document
            .getElementById("resetView")
            .addEventListener("click", () => this.resetView());

          // Search functionality
          document
            .getElementById("searchInput")
            .addEventListener("input", this.onSearch.bind(this));

          // Window resize
          window.addEventListener("resize", this.onResize.bind(this));
        }

        async loadData() {
          try {
            const response = await fetch(this.dataUrl);
            this.rawData = await response.json();
            this.processData();
          } catch (error) {
            console.error("Error loading data:", error);
            this.showError("Failed to load project data");
          }
        }

        processData() {
          this.nodes = [];
          const processNode = (data, level = 0, parent = null) => {
            const node = {
              id: Math.random().toString(36).substr(2, 9),
              text: data.text || data.name || "Unknown",
              level: level,
              parent: parent,
              children: [],
              x: 0,
              y: 0,
              targetX: 0,
              targetY: 0,
              width: 0,
              height: 40,
              color: this.determineNodeColor(
                data.text || data.name || "",
                level
              ),
              icon: data.icon || "fas fa-circle",
              expanded: level === 0 ? true : data.opened !== false, // Root starts expanded
              visible: level === 0 ? true : parent ? parent.expanded : false, // Only visible if parent is expanded
              opacity: 1,
            };

            this.nodes.push(node);

            if (data.children && Array.isArray(data.children)) {
              data.children.forEach((child) => {
                const childNode = processNode(child, level + 1, node);
                node.children.push(childNode);
              });
            }

            return node;
          };

          this.rawData.forEach((rootData) => {
            processNode(rootData, 0);
          });

          // After processing, ensure proper visibility state
          this.initializeVisibility();
          this.calculateNodeSizes();
        }

        initializeVisibility() {
          // Set initial visibility based on parent expansion state
          this.nodes.forEach((node) => {
            if (node.level === 0) {
              node.visible = true; // Root is always visible
            } else if (node.parent) {
              node.visible = node.parent.expanded && node.parent.visible;
            }
          });
        }

        determineNodeColor(text, level) {
          if (level === 0) return this.nodeColors.root;
          if (text.includes("ðŸ“‹") || text.includes("Assigned"))
            return this.nodeColors.assigned;
          if (text.includes("ðŸ‘¥") || text.includes("Resources ("))
            return this.nodeColors.resources;
          if (text.includes("ðŸ‘¤")) return this.nodeColors.resource;
          if (text.includes("ðŸŽ¯") || text.includes("POC"))
            return this.nodeColors.poc;
          if (level === 1) return this.nodeColors.project;
          return this.nodeColors.default;
        }

        calculateNodeSizes() {
          this.ctx.font = "14px Arial";
          this.nodes.forEach((node) => {
            const textMetrics = this.ctx.measureText(node.text);
            node.width = Math.max(textMetrics.width + 40, 120);
          });
        }

        layoutNodes() {
          if (this.nodes.length === 0) return;

          const margin = { x: 150, y: 100 };
          const levelHeight = this.isVerticalLayout ? 120 : 200;
          const nodeSpacing = this.isVerticalLayout ? 30 : 50;

          // Group nodes by level and only include visible nodes
          const levels = {};
          this.nodes.forEach((node) => {
            if (node.visible) {
              if (!levels[node.level]) levels[node.level] = [];
              levels[node.level].push(node);
            }
          });

          // Calculate positions for each level
          Object.keys(levels).forEach((level) => {
            const levelNodes = levels[level];
            const totalWidth = levelNodes.reduce(
              (sum, node) => sum + node.width + nodeSpacing,
              -nodeSpacing
            );

            let currentX = -totalWidth / 2;
            levelNodes.forEach((node) => {
              if (this.isVerticalLayout) {
                node.targetX = currentX + node.width / 2;
                node.targetY = parseInt(level) * levelHeight + margin.y;
              } else {
                // Horizontal layout - increase spacing between levels
                node.targetX = parseInt(level) * levelHeight + margin.x;
                node.targetY = currentX + node.width / 2;
              }
              currentX += node.width + nodeSpacing;
            });
          });

          // Initialize positions if not set
          this.nodes.forEach((node) => {
            if (node.x === 0 && node.y === 0) {
              node.x = node.targetX;
              node.y = node.targetY;
            }
          });

          if (this.animationEnabled) {
            this.animateToTargets();
          } else {
            this.nodes.forEach((node) => {
              node.x = node.targetX;
              node.y = node.targetY;
            });
          }
        }

        animateToTargets() {
          const animate = () => {
            let needsUpdate = false;

            this.nodes.forEach((node) => {
              const dx = node.targetX - node.x;
              const dy = node.targetY - node.y;

              if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                node.x += dx * 0.1;
                node.y += dy * 0.1;
                needsUpdate = true;
              } else {
                node.x = node.targetX;
                node.y = node.targetY;
              }
            });

            if (needsUpdate) {
              this.render();
              this.animationFrame = requestAnimationFrame(animate);
            }
          };

          if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
          }
          this.animationFrame = requestAnimationFrame(animate);
        }

        render() {
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Save context
          this.ctx.save();

          // Apply zoom and pan
          this.ctx.translate(this.panX, this.panY);
          this.ctx.scale(this.zoom, this.zoom);

          // Draw connections first
          this.drawConnections();

          // Draw nodes
          this.drawNodes();

          // Restore context
          this.ctx.restore();
        }

        drawConnections() {
          this.ctx.strokeStyle = "#bdc3c7";
          this.ctx.lineWidth = 2;

          this.nodes.forEach((node) => {
            if (node.parent && node.visible && node.parent.visible) {
              this.ctx.beginPath();
              this.ctx.moveTo(
                node.parent.x,
                node.parent.y + node.parent.height / 2
              );

              if (this.isVerticalLayout) {
                const midY = (node.parent.y + node.y) / 2;
                this.ctx.lineTo(node.parent.x, midY);
                this.ctx.lineTo(node.x, midY);
                this.ctx.lineTo(node.x, node.y - node.height / 2);
              } else {
                const midX = (node.parent.x + node.x) / 2;
                this.ctx.lineTo(midX, node.parent.y + node.parent.height / 2);
                this.ctx.lineTo(midX, node.y);
                this.ctx.lineTo(node.x - node.width / 2, node.y);
              }

              this.ctx.stroke();
            }
          });
        }

        drawNodes() {
          this.nodes.forEach((node) => {
            if (!node.visible) return;

            const isSelected = node === this.selectedNode;
            const isHovered = node === this.hoveredNode;

            // Node background
            this.ctx.fillStyle = node.color;
            this.ctx.globalAlpha = node.opacity;

            if (isSelected || isHovered) {
              this.ctx.shadowColor = "rgba(0, 0, 0, 0.3)";
              this.ctx.shadowBlur = isSelected ? 15 : 10;
              this.ctx.shadowOffsetX = 2;
              this.ctx.shadowOffsetY = 2;
            }

            // Draw rounded rectangle
            this.drawRoundedRect(
              node.x - node.width / 2,
              node.y - node.height / 2,
              node.width,
              node.height,
              8
            );

            this.ctx.fill();

            // Border
            if (isSelected) {
              this.ctx.strokeStyle = "#2c3e50";
              this.ctx.lineWidth = 3;
              this.ctx.stroke();
            } else if (isHovered) {
              this.ctx.strokeStyle = "#34495e";
              this.ctx.lineWidth = 2;
              this.ctx.stroke();
            }

            // Reset shadow
            this.ctx.shadowColor = "transparent";
            this.ctx.shadowBlur = 0;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;

            // Text
            this.ctx.fillStyle = this.getTextColor(node.color);
            this.ctx.font = isSelected ? "bold 14px Arial" : "14px Arial";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";

            // Truncate text if too long
            let displayText = node.text;
            const maxWidth = node.width - 20;
            const textMetrics = this.ctx.measureText(displayText);

            if (textMetrics.width > maxWidth) {
              while (
                this.ctx.measureText(displayText + "...").width > maxWidth &&
                displayText.length > 0
              ) {
                displayText = displayText.slice(0, -1);
              }
              displayText += "...";
            }

            this.ctx.fillText(displayText, node.x, node.y);

            // Expand/collapse indicator for nodes with children
            if (node.children.length > 0) {
              // Draw a circular background for the indicator
              const indicatorSize = 16;
              const indicatorX = node.x + node.width / 2 - indicatorSize / 2;
              const indicatorY = node.y - node.height / 2 + indicatorSize / 2;

              this.ctx.fillStyle = isHovered ? "#34495e" : "#95a5a6";
              this.ctx.beginPath();
              this.ctx.arc(
                indicatorX,
                indicatorY,
                indicatorSize / 2,
                0,
                2 * Math.PI
              );
              this.ctx.fill();

              // Draw the + or - symbol
              this.ctx.fillStyle = "#ffffff";
              this.ctx.font = "bold 12px Arial";
              this.ctx.textAlign = "center";
              this.ctx.textBaseline = "middle";
              const indicator = node.expanded ? "âˆ’" : "+";
              this.ctx.fillText(indicator, indicatorX, indicatorY);
            }

            this.ctx.globalAlpha = 1;
          });
        }

        drawRoundedRect(x, y, width, height, radius) {
          this.ctx.beginPath();
          this.ctx.moveTo(x + radius, y);
          this.ctx.lineTo(x + width - radius, y);
          this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          this.ctx.lineTo(x + width, y + height - radius);
          this.ctx.quadraticCurveTo(
            x + width,
            y + height,
            x + width - radius,
            y + height
          );
          this.ctx.lineTo(x + radius, y + height);
          this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          this.ctx.lineTo(x, y + radius);
          this.ctx.quadraticCurveTo(x, y, x + radius, y);
          this.ctx.closePath();
        }

        getTextColor(backgroundColor) {
          // Simple contrast calculation
          const hex = backgroundColor.replace("#", "");
          const r = parseInt(hex.substr(0, 2), 16);
          const g = parseInt(hex.substr(2, 2), 16);
          const b = parseInt(hex.substr(4, 2), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.5 ? "#2c3e50" : "#ffffff";
        }

        // Event handlers
        onMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const clickedNode = this.getNodeAtPosition(x, y);
          if (clickedNode) {
            this.selectedNode = clickedNode;
            this.showNodeInfo(clickedNode);
          } else {
            this.isDragging = true;
            this.canvas.style.cursor = "grabbing";
            document
              .getElementById("canvasContainer")
              .classList.add("dragging");
          }

          this.lastMousePos = { x, y };
          this.render();
        }

        onMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          if (this.isDragging) {
            const dx = x - this.lastMousePos.x;
            const dy = y - this.lastMousePos.y;
            this.panX += dx;
            this.panY += dy;
            this.render();
          } else {
            const hoveredNode = this.getNodeAtPosition(x, y);
            if (hoveredNode !== this.hoveredNode) {
              this.hoveredNode = hoveredNode;
              this.canvas.style.cursor = hoveredNode ? "pointer" : "grab";
              this.render();
            }
          }

          this.lastMousePos = { x, y };
        }

        onMouseUp(e) {
          this.isDragging = false;
          this.canvas.style.cursor = "grab";
          document
            .getElementById("canvasContainer")
            .classList.remove("dragging");
        }

        onClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          const clickedNode = this.getNodeAtPosition(x, y);
          if (clickedNode && clickedNode.children.length > 0) {
            this.toggleNodeExpansion(clickedNode);
          }
        }

        onWheel(e) {
          e.preventDefault();
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          this.setZoom(this.zoom * delta);
        }

        onTouchStart(e) {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseDown({
              clientX: touch.clientX,
              clientY: touch.clientY,
            });
          }
        }

        onTouchMove(e) {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            this.onMouseMove({
              clientX: touch.clientX,
              clientY: touch.clientY,
            });
          }
        }

        onTouchEnd(e) {
          this.onMouseUp(e);
        }

        onResize() {
          this.setupCanvas();
          this.render();
        }

        onSearch(e) {
          const searchTerm = e.target.value.toLowerCase();
          this.searchNodes(searchTerm);
        }

        // Utility methods
        getNodeAtPosition(x, y) {
          // Convert screen coordinates to canvas coordinates
          const canvasX = (x - this.panX) / this.zoom;
          const canvasY = (y - this.panY) / this.zoom;

          for (const node of this.nodes) {
            if (!node.visible) continue;

            const left = node.x - node.width / 2;
            const right = node.x + node.width / 2;
            const top = node.y - node.height / 2;
            const bottom = node.y + node.height / 2;

            if (
              canvasX >= left &&
              canvasX <= right &&
              canvasY >= top &&
              canvasY <= bottom
            ) {
              return node;
            }
          }

          return null;
        }

        toggleNodeExpansion(node) {
          node.expanded = !node.expanded;
          this.updateChildrenVisibility(node);
          this.layoutNodes();
          this.render();
        }

        updateChildrenVisibility(node) {
          node.children.forEach((child) => {
            if (node.expanded) {
              child.visible = true;
              // If child is also expanded, show its children
              if (child.expanded) {
                this.updateChildrenVisibility(child);
              }
            } else {
              // Hide all descendants when node is collapsed
              child.visible = false;
              this.hideAllDescendants(child);
            }
          });
        }

        hideAllDescendants(node) {
          node.children.forEach((child) => {
            child.visible = false;
            this.hideAllDescendants(child);
          });
        }

        searchNodes(searchTerm) {
          this.nodes.forEach((node) => {
            const matches = node.text.toLowerCase().includes(searchTerm);
            node.opacity = searchTerm === "" || matches ? 1 : 0.3;
          });
          this.render();
        }

        showNodeInfo(node) {
          const infoPanel = document.getElementById("infoPanel");
          const nodeInfo = document.getElementById("nodeInfo");

          nodeInfo.innerHTML = `
                    <p><strong>Name:</strong> ${node.text}</p>
                    <p><strong>Level:</strong> ${node.level}</p>
                    <p><strong>Children:</strong> ${node.children.length}</p>
                    <p><strong>Type:</strong> ${this.getNodeType(node)}</p>
                `;

          infoPanel.style.display = "block";
        }

        getNodeType(node) {
          if (node.level === 0) return "Root";
          if (node.text.includes("ðŸ“‹")) return "Assigned Resource";
          if (node.text.includes("ðŸ‘¥")) return "Resource Group";
          if (node.text.includes("ðŸ‘¤")) return "Individual Resource";
          if (node.text.includes("ðŸŽ¯")) return "Point of Contact";
          if (node.level === 1) return "Project";
          return "Other";
        }

        // Control methods
        zoomIn() {
          this.setZoom(this.zoom * 1.2);
        }

        zoomOut() {
          this.setZoom(this.zoom / 1.2);
        }

        setZoom(newZoom) {
          this.zoom = Math.max(0.1, Math.min(5, newZoom));
          document.getElementById("zoomLevel").textContent =
            Math.round(this.zoom * 100) + "%";
          this.render();
        }

        centerView() {
          if (this.nodes.length === 0) return;

          const bounds = this.calculateBounds();
          const centerX = (bounds.minX + bounds.maxX) / 2;
          const centerY = (bounds.minY + bounds.maxY) / 2;

          this.panX = this.canvas.width / 2 - centerX * this.zoom;
          this.panY = this.canvas.height / 2 - centerY * this.zoom;
          this.render();
        }

        fitToView() {
          if (this.nodes.length === 0) return;

          const bounds = this.calculateBounds();
          const padding = 50;

          const scaleX =
            (this.canvas.width - padding * 2) / (bounds.maxX - bounds.minX);
          const scaleY =
            (this.canvas.height - padding * 2) / (bounds.maxY - bounds.minY);

          this.setZoom(Math.min(scaleX, scaleY, 2));
          this.centerView();
        }

        calculateBounds() {
          let minX = Infinity,
            maxX = -Infinity;
          let minY = Infinity,
            maxY = -Infinity;

          this.nodes.forEach((node) => {
            if (!node.visible) return;
            minX = Math.min(minX, node.x - node.width / 2);
            maxX = Math.max(maxX, node.x + node.width / 2);
            minY = Math.min(minY, node.y - node.height / 2);
            maxY = Math.max(maxY, node.y + node.height / 2);
          });

          return { minX, maxX, minY, maxY };
        }

        setLayout(isVertical) {
          this.isVerticalLayout = isVertical;
          this.layoutNodes();
        }

        toggleAnimation() {
          this.animationEnabled = !this.animationEnabled;
          const btn = document.getElementById("toggleAnimation");
          btn.innerHTML = this.animationEnabled
            ? '<i class="fas fa-pause"></i> Pause'
            : '<i class="fas fa-play"></i> Play';
        }

        resetView() {
          this.zoom = 1;
          this.panX = 0;
          this.panY = 0;
          this.selectedNode = null;
          this.hoveredNode = null;
          document.getElementById("searchInput").value = "";
          document.getElementById("infoPanel").style.display = "none";

          // Reset nodes to initial state: root expanded, children collapsed
          this.nodes.forEach((node) => {
            if (node.level === 0) {
              node.visible = true;
              node.expanded = true;
            } else if (node.level === 1) {
              node.visible = true;
              node.expanded = false;
            } else {
              node.visible = false;
              node.expanded = false;
            }
            node.opacity = 1;
          });

          this.layoutNodes();
          this.centerView();
          this.setZoom(1);
        }

        hideLoading() {
          document.getElementById("loadingOverlay").style.display = "none";
        }

        showError(message) {
          document.getElementById("loadingOverlay").innerHTML = `
                    <div style="text-align: center; color: #e74c3c;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; margin-bottom: 20px;"></i>
                        <h4>Error</h4>
                        <p>${message}</p>
                    </div>
                `;
        }
      }

      // Initialize the tree when the page loads
      document.addEventListener("DOMContentLoaded", function () {
        const tree = new InteractiveProjectTree(
          "treeCanvas",
          '{% url "projects:project_tree" %}'
        );
      });
    </script>
    </div>
  </div>
</div>
{% endblock %}
